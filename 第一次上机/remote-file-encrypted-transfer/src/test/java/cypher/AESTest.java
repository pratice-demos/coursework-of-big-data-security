package cypher;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static utils.Utils.*;

public class AESTest {
  AES aes;

  @BeforeEach
  void createAES() {
    int[] key = {
      0x0f, 0x15, 0x71, 0xc9,
      0x47, 0xd9, 0xe8, 0x59,
      0x0c, 0xb7, 0xad, 0xd6,
      0xaf, 0x7f, 0x67, 0x98,
    };
    this.aes = new AES();
    this.aes.init(intToByte(key));
  }

  @AfterEach
  void destoryAES() {
    this.aes = null;
  }

  // 测试 AES 加密和解密
  @Test
  void enAndDeTest() {
    int[] str = {
      0x01, 0x23, 0x45, 0x67,
      0x89, 0xab, 0xcd, 0xef,
      0xfe, 0xdc, 0xba, 0x98,
      0x76, 0x54, 0x32, 0x10,
    };
    System.out.println("plainText:");
    printArrHex(intToByte(str));
    System.out.println();
    byte[] str1 = this.aes.encrypt(intToByte(str));
    System.out.println("encryptText:");
    printArrHex(str1);
    System.out.println();
    byte[] str2 = this.aes.decrypt(str1);
    System.out.println("decryptText:");
    printArrHex(str2);
    assertArrayEquals(intToByte(str), str2);
  }

  // 测试密钥扩展，测试第二轮密钥是否正确
  @Test
  void keyExpansionTest() {
    int[][] key = {
      {0xdc, 0x9b, 0x97, 0x38},
      {0x90, 0x49, 0xfe, 0x81},
      {0x37, 0xdf, 0x72, 0x15},
      {0xb0, 0xe9, 0x3f, 0xa7},
    };
    byte[][] expendKey1 = Arrays.copyOfRange(this.aes.keyList, 4, 8);
    printArrHex(this.aes.keyList);
    assertArrayEquals(intToByte(key), expendKey1);
  }

  // 测试字符串转换为数组
  @Test
  void convertToArrayReverseTest() {
    int[] str = {
      0x0f, 0x15, 0x71, 0xc9,
      0x47, 0xd9, 0xe8, 0x59,
      0x0c, 0xb7, 0xad, 0xd6,
      0xaf, 0x7f, 0x67, 0x98,
    };
    int[][] text = {
      {0x0f, 0x47, 0x0c, 0xaf},
      {0x15, 0xd9, 0xb7, 0x7f},
      {0x71, 0xe8, 0xad, 0x67},
      {0xc9, 0x59, 0xd6, 0x98},
    };
    assertArrayEquals(intToByte(text), convertToArrayReverse(intToByte(str)));
  }

  // 测试字符串转换为数组
  @Test
  void convertToArrayTest() {
    int[] str = {
      0x0f, 0x15, 0x71, 0xc9,
      0x47, 0xd9, 0xe8, 0x59,
      0x0c, 0xb7, 0xad, 0xd6,
      0xaf, 0x7f, 0x67, 0x98,
    };
    int[][] text = {
      {0x0f, 0x15, 0x71, 0xc9},
      {0x47, 0xd9, 0xe8, 0x59},
      {0x0c, 0xb7, 0xad, 0xd6},
      {0xaf, 0x7f, 0x67, 0x98},
    };
    assertArrayEquals(intToByte(text), convertToArray(intToByte(str)));
  }

  // 测试数组转字符串
  @Test
  void convertToStringReverseTest() {
    int[] str = {
      0x0f, 0x15, 0x71, 0xc9,
      0x47, 0xd9, 0xe8, 0x59,
      0x0c, 0xb7, 0xad, 0xd6,
      0xaf, 0x7f, 0x67, 0x98,
    };
    int[][] text = {
      {0x0f, 0x47, 0x0c, 0xaf},
      {0x15, 0xd9, 0xb7, 0x7f},
      {0x71, 0xe8, 0xad, 0x67},
      {0xc9, 0x59, 0xd6, 0x98},
    };
    assertArrayEquals(intToByte(str), convertToStringReverse(intToByte(text)));
  }

  // 测试轮密钥加
  @Test
  void addRoundKeyTest() {
    int[][] a = {
      {0xb9, 0x94, 0x57, 0x75},
      {0xe4, 0x8e, 0x16, 0x51},
      {0x47, 0x20, 0x9a, 0x3f},
      {0xc5, 0xd6, 0xf5, 0x3b}
    };
    int[][] res = {
      {0x65, 0x0f, 0xc0, 0x4d},
      {0x74, 0xc7, 0xe8, 0xd0},
      {0x70, 0xff, 0xe8, 0x2a},
      {0x75, 0x3f, 0xca, 0x9c},
    };
    assertArrayEquals(intToByte(res), this.aes.addRoundKey(intToByte(a), 1));
  }

  // 测试字节替换
  @Test
  void subByteTest() {
    int[] text = {
      0x0e, 0xce, 0xf2, 0xd9
    };
    int[] dealedText = {
      0xab, 0x8b, 0x89, 0x35
    };
    for(int i=0; i<text.length; i++) {
      assertEquals((byte) dealedText[i], this.aes.subByte((byte) text[i]));
    }
  }

  // 测试逆向字节替换
  @Test
  void deSubByteTest() {
    int[] text = {
      0x0e, 0xce, 0xf2, 0xd9
    };
    int[] dealedText = {
      0xd7, 0xec, 0x04, 0xe5
    };
    for(int i=0; i<text.length; i++) {
      assertEquals((byte) dealedText[i], this.aes.deSubByte((byte) text[i]));
    }
  }

  // 测试行移位
  @Test
  void shiftRowsTest() {
    int[][] text = {
      {0x87, 0xf2, 0x4d, 0x97},
      {0xec, 0x6e, 0x4c, 0x90},
      {0x4a, 0xc3, 0x46, 0xe7},
      {0x8c, 0xd8, 0x95, 0xa6},
    };
    int[][] dealedText = {
      {0x87, 0xf2, 0x4d, 0x97},
      {0x6e, 0x4c, 0x90, 0xec},
      {0x46, 0xe7, 0x4a, 0xc3},
      {0xa6, 0x8c, 0xd8, 0x95},
    };
    assertArrayEquals(intToByte(dealedText), this.aes.shiftRows(intToByte(text)));
  }

  // 测试逆向行移位
  @Test
  void deShiftRowsTest() {
    int[][] text = {
      {0x87, 0xf2, 0x4d, 0x97},
      {0x6e, 0x4c, 0x90, 0xec},
      {0x46, 0xe7, 0x4a, 0xc3},
      {0xa6, 0x8c, 0xd8, 0x95},
    };
    int[][] dealedText = {
      {0x87, 0xf2, 0x4d, 0x97},
      {0xec, 0x6e, 0x4c, 0x90},
      {0x4a, 0xc3, 0x46, 0xe7},
      {0x8c, 0xd8, 0x95, 0xa6},
    };
    assertArrayEquals(intToByte(dealedText), this.aes.deShiftRows(intToByte(text)));
  }

  // 测试 GF(2^8) 下乘法
  @Test
  void fieldMulitTest() {
    int[] x = {0x03, 0x02, 0x57, 0x83};
    int[] y = {0x02, 0x57, 0x83, 0x57};
    int[] ans = {0x06, 0xae, 0xc1, 0xc1};
    for(int i=0; i<x.length; i++) {
      assertEquals((byte) ans[i], this.aes.fieldMulit((byte) x[i], (byte) y[i]));
    }
  }

  // 测试列混淆
  @Test
  void mixColumnTest() {
    int[][] text = {
      {0x87, 0xf2, 0x4d, 0x97},
      {0x6e, 0x4c, 0x90, 0xec},
      {0x46, 0xe7, 0x4a, 0xc3},
      {0xa6, 0x8c, 0xd8, 0x95},
    };
    int[][] dealedText = {
      {0x47, 0x40, 0xa3, 0x4c},
      {0x37, 0xd4, 0x70, 0x9f},
      {0x94, 0xe4, 0x3a, 0x42},
      {0xed, 0xa5, 0xa6, 0xbc},
    };
    assertArrayEquals(intToByte(dealedText), this.aes.mixColumn(intToByte(text)));
  }

  // 测试逆向列混淆
  @Test
  void deMixColumnTest() {
    int[][] text = {
      {0x47, 0x40, 0xa3, 0x4c},
      {0x37, 0xd4, 0x70, 0x9f},
      {0x94, 0xe4, 0x3a, 0x42},
      {0xed, 0xa5, 0xa6, 0xbc},
    };
    int[][] dealedText = {
      {0x87, 0xf2, 0x4d, 0x97},
      {0x6e, 0x4c, 0x90, 0xec},
      {0x46, 0xe7, 0x4a, 0xc3},
      {0xa6, 0x8c, 0xd8, 0x95},
    };
    assertArrayEquals(intToByte(dealedText), this.aes.deMixColumn(intToByte(text)));
  }

  // 测试 byte 转 int，int 转 byte，设不发生溢出
  @Test
  void intAndByteTest() {
    int a = 0x87;
    byte b = (byte) a;
    int c = b >= 0 ? b : 0xffffff00 ^ b;
    assertEquals(a, c);
  }
}